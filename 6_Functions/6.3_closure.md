# 6.3 변수의 유효범위와 클로저   
## 참고   
- [모던 JavaScript - 변수의 유효범위와 클로저](https://ko.javascript.info/closure)

## 개요
javascript를 사용하다보면 여러가지 궁금증들이 생기게 된다.

1. 변수는 어디에 있는가? 기존에 선언된 변수는 어떻게 찾아오는가?
2. 한참전에 작성된 코드는 어떻게 호출되는가?

이런 궁금증들에 대한 개념은 스코프, 클로저 개념과 연관이 깊다.
javascript는 우리가 알고 있든 엔진이 존재하고 이 엔진이 js 소스코드를 해석한다.
스코프와 클로저는 이 엔진이 해석하는 방시과 순서와 밀접하게 연관 되어 있다.

### 왜 스코프가 필요한가?
- javascript 엔진 관점에서 소스를 해석할 때 중요한 건 **식별자 해결**이다.
- 식별자 해결을 잘하기 위해 javascript 엔진은 context라는 단위를 가진다.
- 이 context를 어떤 단위로 가져는 지에 대한 기준은 아래서 배울 수 있는 **lexical environment**이다.
- 우리는 동일한 변수명을 사용할 수 있다. 하지만 같은 스코프 영역에 동일한 변수명이 사용하면 에러가 발생한다.
- 결국엔, **좀 더 식별자 해결을 잘 하기 위해서 사용하는 개념을 스코프**라고 봐도 된다.

## 코드 블럭
-`{...}` 안에 작성된 내용을 코드블럭이라고 한다.
- 코드 블럭 안에 선언된 변수는 코드 블럭 안에서만 사용할 수 있다.
- 변수의 유효범위를 지정하는 단위, 묶음이 된다.
- 코드 블럭이 없는 상태에서 동일한 변수명을 선언하면 에러가 발생한다.
- 코드 블럭에는 흔시 사용하는 `if`, `while`, `for` 가 있다.

```javascript
let message = 'modern'
let message = 'javasript' // error

{
  let message = 'modern'
  alert(message) // modern
}

{
  let message = 'javascript'
  alert(message) // javascript
}

if (true) {
  // 하나의 코드 블럭으로 여기에 선언된 변수는 밖에서 사용하지 못한다.
}
```

## 렉시컬 환경
### 개요
- 렉시컬 환경을 이해하기 위한 약간의 도움 설명이 되겠다.
- javascript 코드 블럭에는 **렉시컬 환경(Lexical Environmnet)**가 존재하고 여기에 포함된 모든 데이터를 통틀어서 **렉시컬 환경 객체**라고 부른다.
  - **환경 레코드(Environmnet Record, EC)** - this와 같은 정보도 여기에 저장
  - **외부 렉시컬 환경(Outer Lexical Environment, OLE)에 대한 참조** - 외부 코드와 연관  
![스크린샷 2021-07-15 오후 7 52 04](https://user-images.githubusercontent.com/87314128/125777366-34772eac-adb6-43f1-bfac-33b3a923c8da.png)

- javascript 엔진이 js 소스를 해석하는 순서를 아래와 같다.
  - 함수 선언문 > 표현식(함수 표현식, 변수 모두 포함)
  - 함수 표현식 예_ `const say = function () {...}`  
- 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다.  

### 함수 선언문, 변수
```javascript
let pharse = 'hello'

function say (name) {
  const sayName = 'name'
  console.log(`${pharse} ${name}`)
}

say('modern javascript')
```

javascript 엔진이 위 소스를 만나서 해석하는 순서를 알아보자.   
1. `say` 라는 함수 선언문을 만나게 되어 초기화하여 저장
2. 표현식 해석, 즉 `pharse` 변수 해석
3. `say()` 실행 컨텍스트 만남
4. 실제 `say` 함수 내부 소스 코드 해석 실행
5. 함수 내주 소스는 위 순서와 동일하게 반복

![스크린샷 2021-07-15 오후 7 56 46](https://user-images.githubusercontent.com/87314128/125777395-d8091384-fb61-4a93-9f3c-09ca6cc83f8b.png)

여기서 함수 안에 선언한 변수가 아니지만 우리는 `pharse`라는 변수를 함수 `say` 함수 안엔서 사용할 수 있다.   
그 이유는 무엇알까?   
바로 **외부 렉시컬 환경을 참조**하기 때문이다. javascript는 저장된 환경 레코드에서 원하는 변수를 찾지 못하면 외부 렉시컬 환경에서 찾는다.   
현재 `say` 함수의 외부 렉시컬 환경은 전역 렉시컬 환경이 되므로 전역에 있는 pharse라는 변수를 사용할 수 있는 것이다.
　

## 클로저
- 클로저는 외부 변수를 기억하고 있다 외부 변수에 접근할 수 있는 함수를 의미한다.
- javascipt는 모든 함수가 클로저 속성을 지원한다.(new Function 문법은 예외)
　   
---   
|이전페이지|다음페이지|
|:---|---:|
|[`◀ 6.2 나머지 매개변수와 전개 문법`](./6.2_rest-parameters-spread.md)|[`6.4 오래된 'var' ▶`](./6.4_var.md)|
